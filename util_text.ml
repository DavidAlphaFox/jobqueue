open Printf
open Batteries

let ws_re  = Pcre.regexp "[ \r\t\n]+"
let split_ws s = Pcre.split ~rex:ws_re s

let string_of_string_option =
  function None -> "None" | Some s -> Printf.sprintf "%s" s

let id x = x
let string_of_list f l = "[" ^ (String.concat "; " (List.map f l)) ^ "]"
let string_of_pair f g (x,y) = Printf.sprintf "(%s, %s)" (f x) (g y)
let string_of_string_pair (s1,s2) = Printf.sprintf "-H \"%s: %s\"" s1 s2
let string_of_string_pair_list = string_of_list string_of_string_pair

(*
  ascii_lowercase only downcases ascii characters A-Z,
  unlike String.lowercase which assumes iso-8859-1, badly breaking multibyte
  UTF-8 characters.
*)
let ascii_lowercase s0 =
  let s = String.create (String.length s0) in
  for i = 0 to String.length s - 1 do
    let c =
      match s0.[i] with
          'A'..'Z' as c -> Char.chr (Char.code c + 32)
        | c -> c
    in
    s.[i] <- c
  done;
  s

let test_ascii_lowercase () =
  ascii_lowercase "ABcd-wxYZ\xC0\xC8G" = "abcd-wxyz\xC0\xC8g"

let validate_utf8 path s =
  if Utf8val.is_allowed_unicode s then None
  else
    let msg =
      Printf.sprintf "Malformed UTF-8: %S"
        (if String.length s <= 100 then s
         else String.sub s 0 100 ^ " ...")
    in
    Some (Ag_util.Validation.error ~msg path)

let elliptify n s =
  let suf = " ..." in
  let suflen = String.length suf in
  let n = max suflen n in
  let len = String.length s in
  if len <= n then s
  else
    String.sub s 0 (n - suflen) ^ suf

(*
  Function called by each *_of_string function generated by:
    atdgen -j -j-pp Util_text.pp_utf8

  It replaces code points in forbidden Unicode areas by a safe character
  (even if they are \u escaped)
*)
let pp_utf8 s =
  if Utf8val.is_json_compatible s then s
  else
    match Utf8val.fix_json_compatible s with
        Some s -> s
      | None ->
          failwith (
            sprintf "Invalid UTF8-JSON: %S\n" (elliptify 300 s)
          )

let looks_binary s =
  let len = String.length s in
  let control = ref 0 in
  for i = 0 to len - 1 do
    if Char.code s.[i] < 32 then
      incr control
  done;
  float !control /. float len >= 0.10

let email_address_regex = Pcre.regexp "[^@]+@[^@]+\\.[^@]+"

let looks_like_email_address s = Pcre.pmatch ~rex:email_address_regex s

let string_of_binary ?(maxlen = 60) s =
  let len = String.length s in
  if len <= maxlen then
    sprintf "[binary data; length: %i]: %S" len s
  else
    sprintf "[binary data; length: %i]: %S..." len (String.sub s 0 maxlen)

let loggable s =
  if looks_binary s then
    string_of_binary s
  else
    s

let prettify s =
  try "JSON\n" ^ Yojson.Basic.prettify s ^ "\n"
  with _ ->
    if looks_binary s then
      string_of_binary s
    else
      s

let tests = [
  "ascii_lowercase", test_ascii_lowercase;
  "utf8 (ascii)",
    (fun () -> Utf8val.is_utf8 "abc");
  "utf8 (byte128)",
    (fun () -> not (Utf8val.is_utf8 "\128"));
  "utf8 (byte128 in a longer string)",
    (fun () ->  not (Utf8val.is_utf8 "a\128b"));
]

let find_matching_substring input regex str =
  try
    let subs = Pcre.exec ~pat:regex str in
    let (st, en) = Pcre.get_substring_ofs subs 0 in
    let sub_len = en - st in
    Some (Some { Api_t.offset = st; length = sub_len })
  with Not_found -> None

